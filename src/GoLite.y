/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */
%{


#include <stdio.h>
#include <stdlib.h>

// Reference to the line number generated by the scanner
extern int yylineno;
// Reference to the yylex function to quiet a compiler warning
int yylex();

// The yyerror function is called on any syntax error. When using %error-verbose, this function
// takes a single argument (a string) which contains a detailed explanation of the error.
// Otherwise it takes no arguments and it is up to the user to format the error using a minimal
// description provided in yytext.
void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}
%}


/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */
%union {
	int intval;
	char *identifier;
    float floatval;
    char *strval;
    int boolval;
}

/* Token directives define the token types to be returned by the scanner (excluding character
 * tokens). Each token definition takes [optionally, a reference to the associated field in the
 * yylval union] and an identifier. Multiple tokens can eb defined per directive by using a list
 * of identifiers separated by spaces.
 */
%token tINT
%token tFLOAT
%token tSTRING
%token tBOOL
%token tRUNE
%token tINTLITERAL
%token tFLOATLITERAL
%token tSTRINGLITERAL
%token tBOOLLITERAL
%token tRUNELITERAL
%token tIDENTIFIER
%token tTYPE
%token tSTRUCT
%token tFUNC
%token tGEQ
%token tLEQ
%token tNEQ
%token tEQ
%token tLSHIFT
%token tRSHIFT
%token tANDNOT
%token tDOUBLEPLUS
%token tDOUBLEMINUS
%token tVAR
%token tPRINT
%token tPRINTLN
%token tBREAK
%token tCONTINUE
%token tAPPEND
%token tLEN
%token tCAP
%token tREAD
%token tWHILE
%token tIF
%token tELSE
%token tFOR
%token tSWITCH
%token tCASE
%token tDEFAULT
%token tRETURN
%token tCOLONASSIGN
%token tAND
%token tOR
%token tPACKAGE
%token UNARY

/* Precedence directives resolve grammar ambiguities by breaking ties between shift/reduce
 * operations. Tokens are grouped into precendence levels, with lower precedence coming first
 * and then higher precedence in later directives. Tokens specified in the same directive have
 * the same precedence. Ties at the same level are broken using either %left or %right, which
 * denote left-associative and right-associative respectively.
 */



%left tOR
%left tAND
%left tEQ tNEQ 
%left tGEQ tLEQ '>' '<'
%left '+' '-'
%left '*' '/'
%left UNARY

/* Start token (by default if this is missing it takes the first production */
%start prgrm

/* Generate the yylloc structure used for storing line numbers with tokens */
%locations
/* Generate detailed error messages */
%error-verbose

/* The second section of a bison file contains the productions. Note that rules with the
 * same LHS may be joined together and separated with a pipe.
 */
%% 

/* Represents the entire program. Makes sure there is only one package dec */
prgrm           : tPACKAGE tIDENTIFIER stmts
                ;

/* Expressions of all kinds. Expands to trm for precedence reasons. Other predecence
is to be solved using directives. */
exp             : '+' exp %prec UNARY
                | '-' exp %prec UNARY
                | '!' exp %prec UNARY
                | '^' exp %prec UNARY
                | exp '<' exp
                | exp '>' exp
                | exp tEQ exp
                | exp tNEQ exp
                | exp tGEQ exp
                | exp tLEQ exp
                | exp tAND exp
                | exp tOR exp
                | exp '+' trm
                | exp '-' trm
                | exp '|' trm
                | exp '^' trm
                | tAPPEND '(' exp ',' exp ')'
                | tLEN '(' exp ')'
                | tCAP '(' exp ')'
                | trm
                ;

/* Expansion of exp for precedence. Expands to ftr */
trm             : trm '*' ftr
                | trm '/' ftr
                | trm '%' ftr
                | trm tLSHIFT ftr
                | trm tRSHIFT ftr
                | trm '&' ftr
                | trm tANDNOT ftr
                | ftr
                ;

/* The final expansion of exp. Can expand back to exp with parentheses. Also handles literals
 and function calls. */
ftr             : '(' exp ')'
                | tIDENTIFIER
                | tINTLITERAL
                | tFLOATLITERAL
                | tBOOLLITERAL
                | tRUNELITERAL
                | tSTRINGLITERAL
                | tRAWSTRINGLITERAL
                | funccall
                ;

/*function calls*/
funccall        : tIDENTIFIER '(' idents ')' ';'
                | tAPPEND '(' exp ',' exp ')' ';'
                | tLEN '(' exp ')' ';'
                | tCAP '(' exp ')' ';'
                ;

/* variable declarations */
dec             : tVAR idents type ';'
                | tVAR decexps ';'
                | tVAR '(' decdistrubted ')'
                | typedec ';'
                ;

/* an arbitrily long list of expressions, separated by commas */
exps            : exps ',' exp
                | exp
                ;

/* an arbitrily long list of identifiers, separated by commas */
idents          : idents ',' tIDENTIFIER
                | tIDENTIFIER
                ;

/* a block of lists of identifiers. Used in the distributed var () type statements. */
blockidents     : blockidents idents

/* A list of comma-separated identifiers and an equally long list of
comma-separated expressions with an equals and possibly a type in the middle.
This kind of structure is required to ensure that the number of idents
and exps is the same, but it might be hard to put into the AST... */ 
decexps         : tIDENTIFIER ',' decexps ',' exp
                | tIDENTIFIER '=' exp
                | tIDENTIFIER type '=' exp
                ;

/* A block of things put into a distributed var () statement */
decdistributed  : decdistributed idents type
                | decdistributed decexps
                | idents type
                | decexps
                ;

/* Used for declaring user-defined types */
typedec         : tTYPE tIDENTIFIER type
                | tTYPE tIDENTIFIER tSTRUCT '{' blockidents '}'
                | tTYPE '(' typedistributed ')'
                ;

/* Used for declaring user defined types with the distributed type () syntax */
typedistributed : typedistributed tIDENTIFIER type
                | typedistributed tIDENTIFIER tSTRUCT '{' blockidents '}'
                | tIDENTIFIER type
                | tIDENTIFIER tSTRUCT '{' blockidents '}'
                ;

/* function definitions */
funcdef         : tFUNC tIDENTIFIER '(' typelist ')' '{' stmts returnstmt '}'
                ;

/* Defines the syntax for types in function headers */
typelist        : typelist ',' tIDENTIFIER type
                | typelist ',' idents type
                | tIDENTIFIER type
                | idents type
                ;

/* Defines the various kinds of types that can be used. Should structs be in here...? */
type            : tINT
                | tFLOAT
                | tBOOL
                | tRUNE
                | tSTRING
                | '[' ']' tINT
                | '[' ']' tFLOAT
                | '[' ']' tBOOL
                | '[' ']' tRUNE
                | '[' ']' tSTRING
                | '[' tINTLITERAL ']' tINT
                | '[' tINTLITERAL ']' tFLOAT
                | '[' tINTLITERAL ']' tBOOL
                | '[' tINTLITERAL ']' tRUNE
                | '[' tINTLITERAL ']' tSTRING
                ;


stmts           : stmts stmt
                | stmt
                ;

/* Defines the kinds of statements that can be used in any context 
A potential issue is having returnstmt in here. Should you be able to return from anywhere?*/
stmt            : simplestmt
                | tPRINT '(' exps ')' ';'
                | tPRINTLN '(' exps ')' ';'
                | tBREAK ';'
                | tCONTINUE ';'
                | ifstmt
                | switchstmt
                | forstmt
                | returnstmt
                ;

/* A subset of statements that can be used in certain extra contexts,
such as before the conditional expressions of if statements */
simplestmt      : funccall ';' 
                | tIDENTIFIER tDOUBLEMINUS ';'
                | tIDENTIFIER tDOUBLEPLUS ';'
                | asnexps ';'
                |
                ;

/* Defines all kinds of if statement, with or without a simplestmt before the conditional */
ifstmt          : tIF exp '{' stmts '}'
                | tIF simplestmt exp '{' stmts '}'
                | tIF exp '{' stmts '}' tELSE '{' stmts '}'
                | tIF simplestmt exp '{' stmts '}' tELSE '{' stmts '}'
                | tIF exp '{' stmts '}' tELSE ifstmt
                | tIF simplestmt exp '{' stmts '}' tELSE ifstmt
                ;

/* Defines switch statements */
switchstmt      : tSWITCH '{' switchbody '}'
                | tSWITCH simplestmt '{' switchbody '}'
                | tSWITCH exp '{' switchbody '}'
                | tSWITCH simplestmt exp '{' switchbody '}'
                ;

/* Defines the body of a switch statement */
switchbody      : switchbody tCASE exps ':' stmts
                | switchbody tDEFAULT ':' stmts
                | tCASE exps ':' stmts
                | tDEFAULT exps ':' stmts
                ;

/* Defines all three supported kinds of support statements */
forstmt         : tFOR '{' stmts '}'
                | tFOR exp '{' stmts '}'
                | tFOR simplestmt exp simplestmt '{' stmts '}'
                ;

/* Defines return statements */
returnstmt      : tRETURN ';'
                | tRETURN exp ';'
                ;

/* Defines the kind of valid assignment expressions.
Again, we need to account for an equal number of idents and exps on either side.
We also need to account for the operand-equals construction. */
asnexps         : tIDENTIFIER ',' asnexps ',' exp
                | tIDENTIFIER '=' exp
                | tIDENTIFIER tCOLONASSIGN exp
                | tIDENTIFIER '+' '=' exp
                | tIDENTIFIER '-' '=' exp
                | tIDENTIFIER '*' '=' exp
                | tIDENTIFIER '/' '=' exp
                | tIDENTIFIER '%' '=' exp
                | tIDENTIFIER '&' '=' exp
                | tIDENTIFIER '|' '=' exp
                | tIDENTIFIER '^' '=' exp
                | tIDENTIFIER tANDNOT '=' exp
                | tIDENTIFIER tLSHIFT '=' exp
                | tIDENTIFIER tRSHIFT '=' exp
                ;






%%