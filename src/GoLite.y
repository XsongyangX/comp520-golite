/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */
%{


#include <stdio.h>
#include <stdlib.h>

// Reference to the line number generated by the scanner
extern int yylineno;
// Reference to the yylex function to quiet a compiler warning
int yylex();

// The yyerror function is called on any syntax error. When using %error-verbose, this function
// takes a single argument (a string) which contains a detailed explanation of the error.
// Otherwise it takes no arguments and it is up to the user to format the error using a minimal
// description provided in yytext.
void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}
%}


/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */
%union {
	int intval;
	char *identifier;
    float floatval;
    char *strval;
    int boolval;
}

/* Token directives define the token types to be returned by the scanner (excluding character
 * tokens). Each token definition takes [optionally, a reference to the associated field in the
 * yylval union] and an identifier. Multiple tokens can eb defined per directive by using a list
 * of identifiers separated by spaces.
 */
%token <intval> tINTVAL
%token <floatval> tFLOATVAL
%token <strval> tSTRVAL
%token <boolval> tBOOLVAL
%token <identifier> tIDENTIFIER
%token tGEQ
%token tLEQ
%token tNEQ
%token tEQ
%token tVAR
%token tPRINT
%token tREAD
%token tWHILE
%token tIF
%token tELSE
%token tINT
%token tSTR
%token tBOOL
%token tFLOAT
%token UMINUS

/* Precedence directives resolve grammar ambiguities by breaking ties between shift/reduce
 * operations. Tokens are grouped into precendence levels, with lower precedence coming first
 * and then higher precedence in later directives. Tokens specified in the same directive have
 * the same precedence. Ties at the same level are broken using either %left or %right, which
 * denote left-associative and right-associative respectively.
 */



%left '&'
%left '|'
%left tEQ tNEQ 
%left tGEQ tLEQ '>' '<'
%left '+' '-'
%left '*' '/'
%left UMINUS
%precedence dBlock sBlock
%precedence toPrgrm

/* Start token (by default if this is missing it takes the first production */
%start prgrm

/* Generate the yylloc structure used for storing line numbers with tokens */
%locations
/* Generate detailed error messages */
%error-verbose

/* The second section of a bison file contains the productions. Note that rules with the
 * same LHS may be joined together and separated with a pipe.
 */
%% 
prgrm           : tPACKAGE tIDENTIFIER codeblock
                ;


codeblock       : codeblock decs
                | codeblock stmts
                ;

exp             : '+' exp
                | '-' exp
                | '!' exp
                | '^' exp
                | exp '<' exp
                | exp '>' exp
                | exp tEQ exp
                | exp tNEQ exp
                | exp tGEQ exp
                | exp tLEQ exp
                | exp tAND exp
                | exp tOR exp
                | exp '+' trm
                | exp '-' trm
                | exp '|' trm
                | exp '^' trm
                | tAPPEND '(' exp ',' exp ')'
                | tLEN '(' exp ')'
                | tCAP '(' exp ')'
                | trm
                ;

trm             : trm '*' ftr
                | trm '/' ftr
                | trm '%' ftr
                | trm tLSHIFT ftr
                | trm tRSHIFT ftr
                | trm '&' ftr
                | trm tANDNOT ftr
                | ftr
                ;

ftr             : '(' exp ')'
                | tIDENTIFIER
                | tINTLITERAL
                | tFLOATLITERAL
                | tBOOLLITERAL
                | tRUNELITERAL
                | tSTRINGLITERAL
                | funccall
                ;

dec             : tVAR idents type
                | tVAR decexps
                | tVAR '(' decdistrubted ')'
                ;

exps            : exps ',' exp
                | exp

idents          : idents ',' tIDENTIFIER
                | tIDENTIFIER
                ;

manyidents      : manyidents idents

decexps         : tIDENTIFIER ',' decexps ',' exp
                | tIDENTIFIER '=' exp
                | tIDENTIFIER type '=' exp
                ;

decdistributed  : decdistributed idents type
                | decdistributed decexps
                | idents type
                | decexps
                ;

typedecs        : typedecs typedec
                | typedec
                ;

typedec         : tTYPE tIDENTIFIER type
                | tTYPE tIDENTIFIER tSTRUCT '{' manyidents '}'
                | tTYPE '(' typedistributed ')'
                ;

typedistributed : typedistributed tIDENTIFIER type
                | typedistributed tIDENTIFIER tSTRUCT '{' manyidents '}'
                | tIDENTIFIER type
                | tIDENTIFIER tSTRUCT '{' manyidents '}'
                ;

funcdef         : tFUNC tIDENTIFIER '(' typelist ')' '{' codeblock returnstmt '}'
                ;

typelist        : typelist tIDENTIFIER type
                | typelist idents type
                ;

type            : tINT
                | tFLOAT
                | tBOOL
                | tRUNE
                | tSTRING
                | '[' ']' tINT
                | '[' ']' tFLOAT
                | '[' ']' tBOOL
                | '[' ']' tRUNE
                | '[' ']' tSTRING
                | '[' tINTLITERAL ']' tINT
                | '[' tINTLITERAL ']' tFLOAT
                | '[' tINTLITERAL ']' tBOOL
                | '[' tINTLITERAL ']' tRUNE
                | '[' tINTLITERAL ']' tSTRING
                ;

stmt            : simplestmt
                | tPRINT '(' exps ')' ';'
                | tPRINTLN '(' exps ')' ';'
                | tBREAK ';'
                | tCONTINUE ';'
                | ifstmt
                | switchstmt
                | forstmt
                ;

simplestmt      : funccall ';' 
                | tIDENTIFIER tDOUBLEMINUS ';'
                | tIDENTIFIER tDOUBLEPLUS ';'
                | asnexps ';'
                |
                ;

ifstmt          : tIF exp '{' codeblock '}'
                | tIF simplestmt exp '{' codeblock '}'
                | tIF exp '{' codeblock '}' tELSE '{' codeblock '}'
                | tIF simplestmt exp '{' codeblock '}' tELSE '{' codeblock '}'
                | tIF exp '{' codeblock '}' tELSE ifstmt
                | tIF simplestmt exp '{' codeblock '}' tELSE ifstmt
                ;

switchstmt      : tSWITCH '{' switchbody '}'
                | tSWITCH simplestmt '{' switchbody '}'
                | tSWITCH exp '{' switchbody '}'
                | tSWITCH simplestmt exp '{' switchbody '}'
                ;

switchbody      : switchbody tCASE exps ':' stmts
                | switchbody tDEFAULT ':' stmts
                | tCASE exps ':' stmts
                | tDEFAULT exps ':' stmts
                ;

forstmt         : tFOR '{' codeblock '}'
                | tFOR exp '{' codeblock '}'
                | tFOR simplestmt exp simplestmt '{' codeblock '}'

returnstmt      : tRETURN ';'
                | tRETURN exp ';'

asnexps         : tIDENTIFIER ',' asnexps ',' exp
                | tIDENTIFIER '=' exp
                | tIDENTIFIER ':=' exp
                | tIDENTIFIER '+' '=' exp
                | tIDENTIFIER '-' '=' exp
                | tIDENTIFIER '*' '=' exp
                | tIDENTIFIER '/' '=' exp
                | tIDENTIFIER '%' '=' exp
                | tIDENTIFIER '&' '=' exp
                | tIDENTIFIER '|' '=' exp
                | tIDENTIFIER '^' '=' exp
                | tIDENTIFIER tANDNOT '=' exp
                | tIDENTIFIER tLSHIFT '=' exp
                | tIDENTIFIER tRSHIFT '=' exp






%%