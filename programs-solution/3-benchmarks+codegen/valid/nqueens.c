#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <stdbool.h>
char *my_itoa(int a){ char *tmp=malloc(16); sprintf(tmp, "%d", a); return tmp;}
char *ftoa(double a){ char *tmp = malloc(32); sprintf(tmp, "%+1.6e", a); return tmp;}
char *ctoa(char a){ char *tmp = malloc(2); tmp[0] = a; tmp[1] = '\0'; return tmp;}
struct CODEGEN_BINDING0point {
	int CODEGEN_BINDING1x;
	int CODEGEN_BINDING2y;
};
int CODEGEN_BINDING3queenRecursion(int CODEGEN_BINDING4index);
int CODEGEN_BINDING5chessGridSize;
struct CODEGEN_BINDING7 {
	int size;
	int cap;
	struct CODEGEN_BINDING0point *val;
}CODEGEN_BINDING6queens;
int CODEGEN_BINDING3queenRecursion(int CODEGEN_BINDING4index){
	{
		if (CODEGEN_BINDING4index>=CODEGEN_BINDING5chessGridSize){
			 return 1;
		}
	}
int CODEGEN_BINDING8i;
CODEGEN_BINDING8i = 0;
int CODEGEN_BINDING9j;
CODEGEN_BINDING9j = 0;
	struct CODEGEN_BINDING0point CODEGEN_BINDING10p;
	CODEGEN_BINDING10p.CODEGEN_BINDING2y = 0;
 	CODEGEN_BINDING10p.CODEGEN_BINDING1x = 0;
 int CODEGEN_BINDING11allgood;
CODEGEN_BINDING11allgood = 0;
	struct CODEGEN_BINDING0point CODEGEN_BINDING12p2;
	CODEGEN_BINDING12p2.CODEGEN_BINDING2y = 0;
 	CODEGEN_BINDING12p2.CODEGEN_BINDING1x = 0;
 int CODEGEN_BINDING13solutionFound;
CODEGEN_BINDING13solutionFound = 0;
	int CODEGEN_BINDING14 = CODEGEN_BINDING4index; if(CODEGEN_BINDING6queens.size <= CODEGEN_BINDING14){fprintf(stderr, "Access out of range.\n"); exit(1);}
struct CODEGEN_BINDING0point CODEGEN_BINDING15 = CODEGEN_BINDING6queens.val[CODEGEN_BINDING14];
	CODEGEN_BINDING10p.CODEGEN_BINDING2y = CODEGEN_BINDING15.CODEGEN_BINDING2y;
 	CODEGEN_BINDING10p.CODEGEN_BINDING1x = CODEGEN_BINDING15.CODEGEN_BINDING1x;
 	{
				int CODEGEN_BINDING16 = 0;
		CODEGEN_BINDING8i = CODEGEN_BINDING16;
		while (CODEGEN_BINDING8i<CODEGEN_BINDING5chessGridSize){
			int CODEGEN_BINDING17 = CODEGEN_BINDING8i;
			CODEGEN_BINDING10p.CODEGEN_BINDING1x = CODEGEN_BINDING17;
			int CODEGEN_BINDING18 = 1;
			CODEGEN_BINDING11allgood = CODEGEN_BINDING18;
			{
								int CODEGEN_BINDING19 = 0;
				CODEGEN_BINDING9j = CODEGEN_BINDING19;
				while (CODEGEN_BINDING9j<CODEGEN_BINDING4index){
					int CODEGEN_BINDING20 = CODEGEN_BINDING9j; if(CODEGEN_BINDING6queens.size <= CODEGEN_BINDING20){fprintf(stderr, "Access out of range.\n"); exit(1);}
struct CODEGEN_BINDING0point CODEGEN_BINDING21 = CODEGEN_BINDING6queens.val[CODEGEN_BINDING20];
					CODEGEN_BINDING12p2.CODEGEN_BINDING2y = CODEGEN_BINDING21.CODEGEN_BINDING2y;
 					CODEGEN_BINDING12p2.CODEGEN_BINDING1x = CODEGEN_BINDING21.CODEGEN_BINDING1x;
 					{
						if (CODEGEN_BINDING10p.CODEGEN_BINDING1x==CODEGEN_BINDING12p2.CODEGEN_BINDING1x||CODEGEN_BINDING12p2.CODEGEN_BINDING2y-CODEGEN_BINDING10p.CODEGEN_BINDING2y==CODEGEN_BINDING12p2.CODEGEN_BINDING1x-CODEGEN_BINDING10p.CODEGEN_BINDING1x||CODEGEN_BINDING12p2.CODEGEN_BINDING2y-CODEGEN_BINDING10p.CODEGEN_BINDING2y==CODEGEN_BINDING10p.CODEGEN_BINDING1x-CODEGEN_BINDING12p2.CODEGEN_BINDING1x){
							int CODEGEN_BINDING22 = 0;
							CODEGEN_BINDING11allgood = CODEGEN_BINDING22;
							goto BREAK_LABEL23;
						}
					}
				CODEGEN_BINDING9j++;
					continue;
					BREAK_LABEL23:;
				CODEGEN_BINDING9j++;
					break;
				}
			}
			{
				if (CODEGEN_BINDING11allgood==1){
					int CODEGEN_BINDING24 = CODEGEN_BINDING4index; if(CODEGEN_BINDING6queens.size <= CODEGEN_BINDING24){fprintf(stderr, "Access out of range.\n"); exit(1);}
struct CODEGEN_BINDING0point CODEGEN_BINDING25 = CODEGEN_BINDING10p;
					CODEGEN_BINDING6queens.val[CODEGEN_BINDING24].CODEGEN_BINDING2y = CODEGEN_BINDING25.CODEGEN_BINDING2y;
 					CODEGEN_BINDING6queens.val[CODEGEN_BINDING24].CODEGEN_BINDING1x = CODEGEN_BINDING25.CODEGEN_BINDING1x;
 					{
						if (CODEGEN_BINDING3queenRecursion(CODEGEN_BINDING4index+1)==1){
							printf("%s", "["); 
							printf("%d",CODEGEN_BINDING10p.CODEGEN_BINDING1x); 
							printf("%s", ", "); 
							printf("%d",CODEGEN_BINDING10p.CODEGEN_BINDING2y); 
							printf("%s", "]"); 
							printf("\n");
							int CODEGEN_BINDING26 = 1;
							CODEGEN_BINDING13solutionFound = CODEGEN_BINDING26;
							goto BREAK_LABEL27;
						}
					}
				}
			}
		CODEGEN_BINDING8i++;
			continue;
			BREAK_LABEL27:;
		CODEGEN_BINDING8i++;
			break;
		}
	}
	 return CODEGEN_BINDING13solutionFound;
}
void main(){
CODEGEN_BINDING6queens.size = 0; CODEGEN_BINDING6queens.cap = 0;
CODEGEN_BINDING6queens.val = NULL; 
CODEGEN_BINDING5chessGridSize = 27;
int CODEGEN_BINDING28i;
CODEGEN_BINDING28i = 0;
	{
				int CODEGEN_BINDING29 = 0;
		CODEGEN_BINDING28i = CODEGEN_BINDING29;
		while (CODEGEN_BINDING28i<CODEGEN_BINDING5chessGridSize){
			struct CODEGEN_BINDING0point CODEGEN_BINDING30p;
			CODEGEN_BINDING30p.CODEGEN_BINDING2y = 0;
 			CODEGEN_BINDING30p.CODEGEN_BINDING1x = 0;
 			int CODEGEN_BINDING31 = 0;
			CODEGEN_BINDING30p.CODEGEN_BINDING1x = CODEGEN_BINDING31;
			int CODEGEN_BINDING32 = CODEGEN_BINDING28i;
			CODEGEN_BINDING30p.CODEGEN_BINDING2y = CODEGEN_BINDING32;
			struct CODEGEN_BINDING7 CODEGEN_BINDING33;
			CODEGEN_BINDING33.size = CODEGEN_BINDING6queens.size + 1;
			if (CODEGEN_BINDING6queens.size+1 > CODEGEN_BINDING6queens.cap){
				if(CODEGEN_BINDING6queens.cap == 0) CODEGEN_BINDING33.cap = 2;
				else CODEGEN_BINDING33.cap = CODEGEN_BINDING6queens.cap*2;
			CODEGEN_BINDING33.val = malloc(sizeof(struct CODEGEN_BINDING0point)*CODEGEN_BINDING33.cap);
			}
			else{ CODEGEN_BINDING33.cap = CODEGEN_BINDING6queens.cap; CODEGEN_BINDING33.val = CODEGEN_BINDING6queens.val;}
			for( int codegen_i = 0; codegen_i < CODEGEN_BINDING6queens.cap; codegen_i++){
				CODEGEN_BINDING33.val[codegen_i] = CODEGEN_BINDING6queens.val[codegen_i];
			}
CODEGEN_BINDING33.val[CODEGEN_BINDING33.size-1] = CODEGEN_BINDING30p;
struct CODEGEN_BINDING7 CODEGEN_BINDING34 = CODEGEN_BINDING33;
			CODEGEN_BINDING6queens.val = CODEGEN_BINDING34.val; 
			CODEGEN_BINDING6queens.size = CODEGEN_BINDING34.size; 
			CODEGEN_BINDING6queens.cap = CODEGEN_BINDING34.cap; 
		CODEGEN_BINDING28i++;
			continue;
		CODEGEN_BINDING28i++;
		}
	}
CODEGEN_BINDING3queenRecursion(0);}
