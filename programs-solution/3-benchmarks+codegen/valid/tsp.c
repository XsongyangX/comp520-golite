#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <stdbool.h>
char *my_itoa(int a){ char *tmp=malloc(16); sprintf(tmp, "%d", a); return tmp;}
char *ftoa(double a){ char *tmp = malloc(32); sprintf(tmp, "%+1.6e", a); return tmp;}
char *ctoa(char a){ char *tmp = malloc(2); tmp[0] = a; tmp[1] = '\0'; return tmp;}
struct CODEGEN_BINDING3 {
	int size;
	int cap;
	int *val;
};
void CODEGEN_BINDING0permute(int CODEGEN_BINDING1n, struct CODEGEN_BINDING3 CODEGEN_BINDING2A);
int CODEGEN_BINDING4compute_cost(int CODEGEN_BINDING5n, struct CODEGEN_BINDING3 CODEGEN_BINDING6A);
int CODEGEN_BINDING7rand();
struct CODEGEN_BINDING3 CODEGEN_BINDING8s;
int CODEGEN_BINDING9cost_s;
struct CODEGEN_BINDING11 {
	int size;
	int cap;
		struct CODEGEN_BINDING12 {
		int size;
		int cap;
		int *val;
};
struct CODEGEN_BINDING12 *val;
}CODEGEN_BINDING10w;
int CODEGEN_BINDING13r;
int CODEGEN_BINDING7rand(){
	int CODEGEN_BINDING14 = (8121*CODEGEN_BINDING13r+28411)%134456;
	CODEGEN_BINDING13r = CODEGEN_BINDING14;
	 return CODEGEN_BINDING13r;
}
int CODEGEN_BINDING4compute_cost(int CODEGEN_BINDING5n, struct CODEGEN_BINDING12 CODEGEN_BINDING6A){
int CODEGEN_BINDING15sum;
CODEGEN_BINDING15sum = 0;
	{
				int CODEGEN_BINDING16 = 0;
int CODEGEN_BINDING17i = CODEGEN_BINDING16;
		while (CODEGEN_BINDING17i<CODEGEN_BINDING5n-1){
						int CODEGEN_BINDING18 = CODEGEN_BINDING17i+1; if(CODEGEN_BINDING6A.size <= CODEGEN_BINDING18){fprintf(stderr, "Access out of range.\n"); exit(1);}
						int CODEGEN_BINDING19 = CODEGEN_BINDING17i; if(CODEGEN_BINDING6A.size <= CODEGEN_BINDING19){fprintf(stderr, "Access out of range.\n"); exit(1);}
int CODEGEN_BINDING20 = CODEGEN_BINDING6A.val[CODEGEN_BINDING19]; if(CODEGEN_BINDING10w.size <= CODEGEN_BINDING20){fprintf(stderr, "Access out of range.\n"); exit(1);}
int CODEGEN_BINDING21 = CODEGEN_BINDING6A.val[CODEGEN_BINDING18]; if(CODEGEN_BINDING10w.val[CODEGEN_BINDING20].size <= CODEGEN_BINDING21){fprintf(stderr, "Access out of range.\n"); exit(1);}
			int CODEGEN_BINDING22 = CODEGEN_BINDING15sum+CODEGEN_BINDING10w.val[CODEGEN_BINDING20].val[CODEGEN_BINDING21];
			CODEGEN_BINDING15sum = CODEGEN_BINDING22;
		CODEGEN_BINDING17i++;
			continue;
		CODEGEN_BINDING17i++;
		}
	}
		int CODEGEN_BINDING23 = CODEGEN_BINDING5n-1; if(CODEGEN_BINDING10w.size <= CODEGEN_BINDING23){fprintf(stderr, "Access out of range.\n"); exit(1);}
int CODEGEN_BINDING24 = 0; if(CODEGEN_BINDING10w.val[CODEGEN_BINDING23].size <= CODEGEN_BINDING24){fprintf(stderr, "Access out of range.\n"); exit(1);}
	 return CODEGEN_BINDING15sum+CODEGEN_BINDING10w.val[CODEGEN_BINDING23].val[CODEGEN_BINDING24];
}
void CODEGEN_BINDING0permute(int CODEGEN_BINDING1n, struct CODEGEN_BINDING12 CODEGEN_BINDING2A){
	struct CODEGEN_BINDING12 CODEGEN_BINDING25index;
	CODEGEN_BINDING25index.size = 0; CODEGEN_BINDING25index.cap = 0;
	CODEGEN_BINDING25index.val = NULL; 
	{
				int CODEGEN_BINDING26 = 0;
int CODEGEN_BINDING27i = CODEGEN_BINDING26;
		while (CODEGEN_BINDING27i<CODEGEN_BINDING1n){
			struct CODEGEN_BINDING12 CODEGEN_BINDING28;
			CODEGEN_BINDING28.size = CODEGEN_BINDING25index.size + 1;
			if (CODEGEN_BINDING25index.size+1 > CODEGEN_BINDING25index.cap){
				if(CODEGEN_BINDING25index.cap == 0) CODEGEN_BINDING28.cap = 2;
				else CODEGEN_BINDING28.cap = CODEGEN_BINDING25index.cap*2;
			CODEGEN_BINDING28.val = malloc(sizeof(int)*CODEGEN_BINDING28.cap);
			}
			else{ CODEGEN_BINDING28.cap = CODEGEN_BINDING25index.cap; CODEGEN_BINDING28.val = CODEGEN_BINDING25index.val;}
			for( int codegen_i = 0; codegen_i < CODEGEN_BINDING25index.cap; codegen_i++){
				CODEGEN_BINDING28.val[codegen_i] = CODEGEN_BINDING25index.val[codegen_i];
			}
CODEGEN_BINDING28.val[CODEGEN_BINDING28.size-1] = 0;
struct CODEGEN_BINDING12 CODEGEN_BINDING29 = CODEGEN_BINDING28;
			CODEGEN_BINDING25index.val = CODEGEN_BINDING29.val; 
			CODEGEN_BINDING25index.size = CODEGEN_BINDING29.size; 
			CODEGEN_BINDING25index.cap = CODEGEN_BINDING29.cap; 
		CODEGEN_BINDING27i++;
			continue;
		CODEGEN_BINDING27i++;
		}
	}
int CODEGEN_BINDING30temp;
CODEGEN_BINDING30temp = 0;
int CODEGEN_BINDING31swap;
CODEGEN_BINDING31swap = 0;
int CODEGEN_BINDING32cost_i;
CODEGEN_BINDING32cost_i = 0;
	{
				int CODEGEN_BINDING33 = 1;
int CODEGEN_BINDING34i = CODEGEN_BINDING33;
		while (CODEGEN_BINDING34i<CODEGEN_BINDING1n){
			{
				int CODEGEN_BINDING35 = CODEGEN_BINDING34i; if(CODEGEN_BINDING25index.size <= CODEGEN_BINDING35){fprintf(stderr, "Access out of range.\n"); exit(1);}
				if (CODEGEN_BINDING25index.val[CODEGEN_BINDING35]<CODEGEN_BINDING34i){
					int CODEGEN_BINDING36 = CODEGEN_BINDING34i; if(CODEGEN_BINDING25index.size <= CODEGEN_BINDING36){fprintf(stderr, "Access out of range.\n"); exit(1);}
					int CODEGEN_BINDING37 = CODEGEN_BINDING34i%2*CODEGEN_BINDING25index.val[CODEGEN_BINDING36];
					CODEGEN_BINDING31swap = CODEGEN_BINDING37;
					int CODEGEN_BINDING38 = CODEGEN_BINDING31swap; if(CODEGEN_BINDING2A.size <= CODEGEN_BINDING38){fprintf(stderr, "Access out of range.\n"); exit(1);}
					int CODEGEN_BINDING39 = CODEGEN_BINDING2A.val[CODEGEN_BINDING38];
					CODEGEN_BINDING30temp = CODEGEN_BINDING39;
					int CODEGEN_BINDING40 = CODEGEN_BINDING34i; if(CODEGEN_BINDING2A.size <= CODEGEN_BINDING40){fprintf(stderr, "Access out of range.\n"); exit(1);}
					int CODEGEN_BINDING41 = CODEGEN_BINDING31swap; if(CODEGEN_BINDING2A.size <= CODEGEN_BINDING41){fprintf(stderr, "Access out of range.\n"); exit(1);}
					int CODEGEN_BINDING42 = CODEGEN_BINDING2A.val[CODEGEN_BINDING40];
					CODEGEN_BINDING2A.val[CODEGEN_BINDING41] = CODEGEN_BINDING42;
					int CODEGEN_BINDING43 = CODEGEN_BINDING34i; if(CODEGEN_BINDING2A.size <= CODEGEN_BINDING43){fprintf(stderr, "Access out of range.\n"); exit(1);}
					int CODEGEN_BINDING44 = CODEGEN_BINDING30temp;
					CODEGEN_BINDING2A.val[CODEGEN_BINDING43] = CODEGEN_BINDING44;
					int CODEGEN_BINDING45 = CODEGEN_BINDING4compute_cost(CODEGEN_BINDING1n, CODEGEN_BINDING2A);
					CODEGEN_BINDING32cost_i = CODEGEN_BINDING45;
					{
						if (CODEGEN_BINDING32cost_i<CODEGEN_BINDING9cost_s){
							int CODEGEN_BINDING46 = CODEGEN_BINDING32cost_i;
							CODEGEN_BINDING9cost_s = CODEGEN_BINDING46;
							{
																int CODEGEN_BINDING47 = 0;
int CODEGEN_BINDING48j = CODEGEN_BINDING47;
								while (CODEGEN_BINDING48j<CODEGEN_BINDING1n-1){
									int CODEGEN_BINDING49 = CODEGEN_BINDING48j; if(CODEGEN_BINDING2A.size <= CODEGEN_BINDING49){fprintf(stderr, "Access out of range.\n"); exit(1);}
									int CODEGEN_BINDING50 = CODEGEN_BINDING48j; if(CODEGEN_BINDING8s.size <= CODEGEN_BINDING50){fprintf(stderr, "Access out of range.\n"); exit(1);}
									int CODEGEN_BINDING51 = CODEGEN_BINDING2A.val[CODEGEN_BINDING49];
									CODEGEN_BINDING8s.val[CODEGEN_BINDING50] = CODEGEN_BINDING51;
								CODEGEN_BINDING48j++;
									continue;
								CODEGEN_BINDING48j++;
								}
							}
						}
					}
										int CODEGEN_BINDING52 = CODEGEN_BINDING34i; if(CODEGEN_BINDING25index.size <= CODEGEN_BINDING52){fprintf(stderr, "Access out of range.\n"); exit(1);}
CODEGEN_BINDING25index.val[CODEGEN_BINDING52]++;
					int CODEGEN_BINDING53 = 1;
					CODEGEN_BINDING34i = CODEGEN_BINDING53;
				}
else{
					int CODEGEN_BINDING54 = CODEGEN_BINDING34i; if(CODEGEN_BINDING25index.size <= CODEGEN_BINDING54){fprintf(stderr, "Access out of range.\n"); exit(1);}
					int CODEGEN_BINDING55 = 0;
					CODEGEN_BINDING25index.val[CODEGEN_BINDING54] = CODEGEN_BINDING55;
					CODEGEN_BINDING34i++;
				}
			}
			continue;
		}
	}
}
void main(){
CODEGEN_BINDING13r = 0;
CODEGEN_BINDING10w.size = 0; CODEGEN_BINDING10w.cap = 0;
CODEGEN_BINDING10w.val = NULL; 
CODEGEN_BINDING9cost_s = 0;
CODEGEN_BINDING8s.size = 0; CODEGEN_BINDING8s.cap = 0;
CODEGEN_BINDING8s.val = NULL; 
int CODEGEN_BINDING56n;
CODEGEN_BINDING56n = 11;
	{
				int CODEGEN_BINDING57 = 0;
int CODEGEN_BINDING58i = CODEGEN_BINDING57;
		while (CODEGEN_BINDING58i<CODEGEN_BINDING56n){
			struct CODEGEN_BINDING12 CODEGEN_BINDING59;
			CODEGEN_BINDING59.size = CODEGEN_BINDING8s.size + 1;
			if (CODEGEN_BINDING8s.size+1 > CODEGEN_BINDING8s.cap){
				if(CODEGEN_BINDING8s.cap == 0) CODEGEN_BINDING59.cap = 2;
				else CODEGEN_BINDING59.cap = CODEGEN_BINDING8s.cap*2;
			CODEGEN_BINDING59.val = malloc(sizeof(int)*CODEGEN_BINDING59.cap);
			}
			else{ CODEGEN_BINDING59.cap = CODEGEN_BINDING8s.cap; CODEGEN_BINDING59.val = CODEGEN_BINDING8s.val;}
			for( int codegen_i = 0; codegen_i < CODEGEN_BINDING8s.cap; codegen_i++){
				CODEGEN_BINDING59.val[codegen_i] = CODEGEN_BINDING8s.val[codegen_i];
			}
CODEGEN_BINDING59.val[CODEGEN_BINDING59.size-1] = CODEGEN_BINDING58i;
struct CODEGEN_BINDING12 CODEGEN_BINDING60 = CODEGEN_BINDING59;
			CODEGEN_BINDING8s.val = CODEGEN_BINDING60.val; 
			CODEGEN_BINDING8s.size = CODEGEN_BINDING60.size; 
			CODEGEN_BINDING8s.cap = CODEGEN_BINDING60.cap; 
			struct CODEGEN_BINDING12 CODEGEN_BINDING61w_i;
			CODEGEN_BINDING61w_i.size = 0; CODEGEN_BINDING61w_i.cap = 0;
			CODEGEN_BINDING61w_i.val = NULL; 
			{
								int CODEGEN_BINDING62 = 0;
int CODEGEN_BINDING63j = CODEGEN_BINDING62;
				while (CODEGEN_BINDING63j<CODEGEN_BINDING56n){
					struct CODEGEN_BINDING12 CODEGEN_BINDING64;
					CODEGEN_BINDING64.size = CODEGEN_BINDING61w_i.size + 1;
					if (CODEGEN_BINDING61w_i.size+1 > CODEGEN_BINDING61w_i.cap){
						if(CODEGEN_BINDING61w_i.cap == 0) CODEGEN_BINDING64.cap = 2;
						else CODEGEN_BINDING64.cap = CODEGEN_BINDING61w_i.cap*2;
					CODEGEN_BINDING64.val = malloc(sizeof(int)*CODEGEN_BINDING64.cap);
					}
					else{ CODEGEN_BINDING64.cap = CODEGEN_BINDING61w_i.cap; CODEGEN_BINDING64.val = CODEGEN_BINDING61w_i.val;}
					for( int codegen_i = 0; codegen_i < CODEGEN_BINDING61w_i.cap; codegen_i++){
						CODEGEN_BINDING64.val[codegen_i] = CODEGEN_BINDING61w_i.val[codegen_i];
					}
CODEGEN_BINDING64.val[CODEGEN_BINDING64.size-1] = CODEGEN_BINDING7rand();
struct CODEGEN_BINDING12 CODEGEN_BINDING65 = CODEGEN_BINDING64;
					CODEGEN_BINDING61w_i.val = CODEGEN_BINDING65.val; 
					CODEGEN_BINDING61w_i.size = CODEGEN_BINDING65.size; 
					CODEGEN_BINDING61w_i.cap = CODEGEN_BINDING65.cap; 
				CODEGEN_BINDING63j++;
					continue;
				CODEGEN_BINDING63j++;
				}
			}
			struct CODEGEN_BINDING11 CODEGEN_BINDING66;
			CODEGEN_BINDING66.size = CODEGEN_BINDING10w.size + 1;
			if (CODEGEN_BINDING10w.size+1 > CODEGEN_BINDING10w.cap){
				if(CODEGEN_BINDING10w.cap == 0) CODEGEN_BINDING66.cap = 2;
				else CODEGEN_BINDING66.cap = CODEGEN_BINDING10w.cap*2;
			CODEGEN_BINDING66.val = malloc(sizeof(struct CODEGEN_BINDING12)*CODEGEN_BINDING66.cap);
			}
			else{ CODEGEN_BINDING66.cap = CODEGEN_BINDING10w.cap; CODEGEN_BINDING66.val = CODEGEN_BINDING10w.val;}
			for( int codegen_i = 0; codegen_i < CODEGEN_BINDING10w.cap; codegen_i++){
				CODEGEN_BINDING66.val[codegen_i] = CODEGEN_BINDING10w.val[codegen_i];
			}
CODEGEN_BINDING66.val[CODEGEN_BINDING66.size-1] = CODEGEN_BINDING61w_i;
struct CODEGEN_BINDING11 CODEGEN_BINDING67 = CODEGEN_BINDING66;
			CODEGEN_BINDING10w.val = CODEGEN_BINDING67.val; 
			CODEGEN_BINDING10w.size = CODEGEN_BINDING67.size; 
			CODEGEN_BINDING10w.cap = CODEGEN_BINDING67.cap; 
		CODEGEN_BINDING58i++;
			continue;
		CODEGEN_BINDING58i++;
		}
	}
	int CODEGEN_BINDING68 = CODEGEN_BINDING4compute_cost(CODEGEN_BINDING56n, CODEGEN_BINDING8s);
	CODEGEN_BINDING9cost_s = CODEGEN_BINDING68;
	printf("%s", "Ordered path cost:"); 
	printf(" ");
	printf("%d",CODEGEN_BINDING9cost_s); 
	printf("\n");
CODEGEN_BINDING0permute(CODEGEN_BINDING56n, CODEGEN_BINDING8s);	printf("%s", "Optimal path cost:"); 
	printf(" ");
	printf("%d",CODEGEN_BINDING9cost_s); 
	printf("\n");
}
